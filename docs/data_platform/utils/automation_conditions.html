<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>data_platform.utils.automation_conditions API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>data_platform.utils.automation_conditions</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="data_platform.utils.automation_conditions.CustomAutomationCondition"><code class="flex name class">
<span>class <span class="ident">CustomAutomationCondition</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomAutomationCondition(AutomationCondition):
    
    @classmethod
    def get_automation_condition(cls, automation_condition_name: str) -&gt; Optional[AutomationCondition]:
        methods = AutomationCondition.__dict__ | cls.__dict__
        return methods.get(automation_condition_name, None)      


    @staticmethod
    def manual() -&gt; None:
         &#34;&#34;&#34;Returns no AutomationCondition that will require a user to manually trigger.
         Used for overriding default automations for static assets.
         &#34;&#34;&#34;
         return None


    @staticmethod
    def missing_or_changed() -&gt; AutomationCondition:
        &#34;&#34;&#34;Returns no AutomationCondition that will trigger only if the asset has never been
        materialized, or if its definition has changed.

        Common use for dbt seeds that only need to be reloaded when the underlying csv file changes.
         &#34;&#34;&#34;
        return (
            AutomationCondition.in_latest_time_window()
            &amp; (
                AutomationCondition.code_version_changed() | AutomationCondition.newly_missing()
            ).since_last_handled()
            &amp; ~ AutomationCondition.in_progress()
        ).with_label(f&#34;missing_or_changed&#34;)


    @override
    @staticmethod
    def eager() -&gt; AndAutomationCondition:
            &#34;&#34;&#34;Returns an AutomationCondition which will cause a target
            to be executed if any of its dependencies update, and will
            execute missing partitions if they become missing after this
            condition is applied to the target. This will not execute targets
            that have any missing or in progress dependencies,
            or are currently in progress.

            For time partitioned assets, only the latest time partition will be considered.
            Commonly used for assets that are far downstream and have users that directly
            interact with them, and do not have sensitivity to late arriving dimensions.&#34;&#34;&#34;
            return (
                AutomationCondition.in_latest_time_window()
                &amp; (
                    AutomationCondition.newly_missing() | AutomationCondition.any_deps_updated()
                ).since_last_handled()
                &amp; ~AutomationCondition.any_deps_missing()
                &amp; ~AutomationCondition.any_deps_in_progress()
                &amp; ~AutomationCondition.in_progress()
            ).with_label(&#34;eager&#34;)


    @staticmethod
    def eager_with_deps_checks() -&gt; AutomationCondition:
            &#34;&#34;&#34;Returns an AutomationCondition which will cause a target
            to be executed if any of its dependencies update but only after,
            the dependencies blocking checks have passed, and will
            execute missing partitions if they become missing after this
            condition is applied to the target. This will not execute targets
            that have any missing or in progress dependencies,
            or are currently in progress.

            For time partitioned assets, only the latest time partition will be considered.
            Commonly used for assets that are far downstream and have users that directly
            interact with them, and do not have sensitivity to late arriving dimensions.&#34;&#34;&#34;
            return ((AutomationCondition.eager()
                     &amp; AutomationCondition.all_deps_blocking_checks_passed()))    


    @classmethod
    def lazy(cls) -&gt; AutomationCondition:
        &#34;&#34;&#34;Returns an AutomationCondition which will cause a target to be
        executed if any downstream conditions are true or the partition is missing or changed.
        
        Commonly used for intermediate assets that are used for downstream materializations.
        &#34;&#34;&#34;
        return(
            AutomationCondition.any_downstream_conditions() | cls.missing_or_changed()
        ).with_label(&#34;lazy&#34;)
    

    @staticmethod
    def lazy_on_cron(
            cron_schedule: str, cron_timezone: str = &#34;UTC&#34;,
            ignore_asset_keys: list[list[str]]| None = None) -&gt; AutomationCondition:
        &#34;&#34;&#34;Returns an AutomationCondition which will cause a target to be
        executed if any downstream conditions are true or the partition is missing or changed.
        Will limit to only one execution for the given cron_schedule.
        
        Commonly used for intermediate assets that are used for downstream materializations,
        that have high frequency upstream assets, but themselves do not need to be updated as
        frequently.
        &#34;&#34;&#34;
        ignore_asset_keys = ignore_asset_keys or []
        return (
            AutomationCondition.in_latest_time_window()
            &amp; AutomationCondition.cron_tick_passed(
                cron_schedule, cron_timezone
            ).since_last_handled()
            &amp; AutomationCondition.all_deps_updated_since_cron(cron_schedule, cron_timezone).ignore(
            AssetSelection.assets(*ignore_asset_keys))
            &amp; ~ AutomationCondition.in_progress()
        ).with_label(f&#34;lazy_on_cron({cron_schedule}, {cron_timezone})&#34;)
    

    @staticmethod
    @override
    def on_cron(
            cron_schedule: str,
            cron_timezone: str = &#34;UTC&#34;,
            ignore_asset_keys: list[list[str]]| None = None) -&gt; AndAutomationCondition:
        &#34;&#34;&#34;Returns an AutomationCondition which will cause a target to be
        executed on a given cron schedule, after all of its dependencies have
        been updated since the latest tick of that cron schedule.

        For time partitioned assets, only the latest time partition will be considered.
        
        Commonly used for assets that are far downstream and have users that directly
        interact with them, and have sensitivity to late arriving dimensions.&#34;&#34;&#34;
        ignore_asset_keys = ignore_asset_keys or []
        return AutomationCondition.on_cron(cron_schedule, cron_timezone).ignore(
            AssetSelection.assets(*ignore_asset_keys))
    

    @staticmethod
    def on_schedule(cron_schedule: str, cron_timezone: str = &#34;utc&#34;) -&gt; AutomationCondition:
        &#34;&#34;&#34;Returns an AutomationCondition which will cause a target to be executed on a given
        cron schedule, regardless of the state of its dependencies

        For time partitioned assets, only the latest time partition will be considered.

        Commonly used for assets in the ingestion layer that should always run on a scheduled basis,
        and have no way of knowing when the source system has updates.
        &#34;&#34;&#34;
        return (
            AutomationCondition.in_latest_time_window()
            &amp; AutomationCondition.cron_tick_passed(
                cron_schedule, cron_timezone
            ).since_last_handled()
        ).with_label(f&#34;on_schedule({cron_schedule}, {cron_timezone})&#34;)</code></pre>
</details>
<div class="desc"><p>An AutomationCondition represents a condition of an asset that impacts whether it should be
automatically executed. For example, you can have a condition which becomes true whenever the
code version of the asset is changed, or whenever an upstream dependency is updated.</p>
<p>.. code-block:: python</p>
<pre><code>from dagster import AutomationCondition, asset

@asset(automation_condition=AutomationCondition.on_cron("0 0 * * *"))
def my_asset(): ...
</code></pre>
<p>AutomationConditions may be combined together into expressions using a variety of operators.</p>
<p>.. code-block:: python</p>
<pre><code>from dagster import AssetSelection, AutomationCondition, asset

# any dependencies from the "important" group are missing
any_important_deps_missing = AutomationCondition.any_deps_match(
    AutomationCondition.missing(),
).allow(AssetSelection.groups("important"))

# there is a new code version for this asset since the last time it was requested
new_code_version = AutomationCondition.code_version_changed().since(
    AutomationCondition.newly_requested()
)

# there is a new code version and no important dependencies are missing
my_condition = new_code_version &amp; ~any_important_deps_missing

@asset(automation_condition=my_condition)
def my_asset(): ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>dagster._core.definitions.declarative_automation.automation_condition.AutomationCondition</li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="data_platform.utils.automation_conditions.CustomAutomationCondition.eager"><code class="name flex">
<span>def <span class="ident">eager</span></span>(<span>) ‑> dagster._core.definitions.declarative_automation.operators.boolean_operators.AndAutomationCondition</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@override
@staticmethod
def eager() -&gt; AndAutomationCondition:
        &#34;&#34;&#34;Returns an AutomationCondition which will cause a target
        to be executed if any of its dependencies update, and will
        execute missing partitions if they become missing after this
        condition is applied to the target. This will not execute targets
        that have any missing or in progress dependencies,
        or are currently in progress.

        For time partitioned assets, only the latest time partition will be considered.
        Commonly used for assets that are far downstream and have users that directly
        interact with them, and do not have sensitivity to late arriving dimensions.&#34;&#34;&#34;
        return (
            AutomationCondition.in_latest_time_window()
            &amp; (
                AutomationCondition.newly_missing() | AutomationCondition.any_deps_updated()
            ).since_last_handled()
            &amp; ~AutomationCondition.any_deps_missing()
            &amp; ~AutomationCondition.any_deps_in_progress()
            &amp; ~AutomationCondition.in_progress()
        ).with_label(&#34;eager&#34;)</code></pre>
</details>
<div class="desc"><p>Returns an AutomationCondition which will cause a target
to be executed if any of its dependencies update, and will
execute missing partitions if they become missing after this
condition is applied to the target. This will not execute targets
that have any missing or in progress dependencies,
or are currently in progress.</p>
<p>For time partitioned assets, only the latest time partition will be considered.
Commonly used for assets that are far downstream and have users that directly
interact with them, and do not have sensitivity to late arriving dimensions.</p></div>
</dd>
<dt id="data_platform.utils.automation_conditions.CustomAutomationCondition.eager_with_deps_checks"><code class="name flex">
<span>def <span class="ident">eager_with_deps_checks</span></span>(<span>) ‑> dagster._core.definitions.declarative_automation.automation_condition.AutomationCondition</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def eager_with_deps_checks() -&gt; AutomationCondition:
        &#34;&#34;&#34;Returns an AutomationCondition which will cause a target
        to be executed if any of its dependencies update but only after,
        the dependencies blocking checks have passed, and will
        execute missing partitions if they become missing after this
        condition is applied to the target. This will not execute targets
        that have any missing or in progress dependencies,
        or are currently in progress.

        For time partitioned assets, only the latest time partition will be considered.
        Commonly used for assets that are far downstream and have users that directly
        interact with them, and do not have sensitivity to late arriving dimensions.&#34;&#34;&#34;
        return ((AutomationCondition.eager()
                 &amp; AutomationCondition.all_deps_blocking_checks_passed()))    </code></pre>
</details>
<div class="desc"><p>Returns an AutomationCondition which will cause a target
to be executed if any of its dependencies update but only after,
the dependencies blocking checks have passed, and will
execute missing partitions if they become missing after this
condition is applied to the target. This will not execute targets
that have any missing or in progress dependencies,
or are currently in progress.</p>
<p>For time partitioned assets, only the latest time partition will be considered.
Commonly used for assets that are far downstream and have users that directly
interact with them, and do not have sensitivity to late arriving dimensions.</p></div>
</dd>
<dt id="data_platform.utils.automation_conditions.CustomAutomationCondition.get_automation_condition"><code class="name flex">
<span>def <span class="ident">get_automation_condition</span></span>(<span>automation_condition_name: str) ‑> dagster._core.definitions.declarative_automation.automation_condition.AutomationCondition | None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="data_platform.utils.automation_conditions.CustomAutomationCondition.lazy"><code class="name flex">
<span>def <span class="ident">lazy</span></span>(<span>) ‑> dagster._core.definitions.declarative_automation.automation_condition.AutomationCondition</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an AutomationCondition which will cause a target to be
executed if any downstream conditions are true or the partition is missing or changed.</p>
<p>Commonly used for intermediate assets that are used for downstream materializations.</p></div>
</dd>
<dt id="data_platform.utils.automation_conditions.CustomAutomationCondition.lazy_on_cron"><code class="name flex">
<span>def <span class="ident">lazy_on_cron</span></span>(<span>cron_schedule: str,<br>cron_timezone: str = 'UTC',<br>ignore_asset_keys: list[list[str]] | None = None) ‑> dagster._core.definitions.declarative_automation.automation_condition.AutomationCondition</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def lazy_on_cron(
        cron_schedule: str, cron_timezone: str = &#34;UTC&#34;,
        ignore_asset_keys: list[list[str]]| None = None) -&gt; AutomationCondition:
    &#34;&#34;&#34;Returns an AutomationCondition which will cause a target to be
    executed if any downstream conditions are true or the partition is missing or changed.
    Will limit to only one execution for the given cron_schedule.
    
    Commonly used for intermediate assets that are used for downstream materializations,
    that have high frequency upstream assets, but themselves do not need to be updated as
    frequently.
    &#34;&#34;&#34;
    ignore_asset_keys = ignore_asset_keys or []
    return (
        AutomationCondition.in_latest_time_window()
        &amp; AutomationCondition.cron_tick_passed(
            cron_schedule, cron_timezone
        ).since_last_handled()
        &amp; AutomationCondition.all_deps_updated_since_cron(cron_schedule, cron_timezone).ignore(
        AssetSelection.assets(*ignore_asset_keys))
        &amp; ~ AutomationCondition.in_progress()
    ).with_label(f&#34;lazy_on_cron({cron_schedule}, {cron_timezone})&#34;)</code></pre>
</details>
<div class="desc"><p>Returns an AutomationCondition which will cause a target to be
executed if any downstream conditions are true or the partition is missing or changed.
Will limit to only one execution for the given cron_schedule.</p>
<p>Commonly used for intermediate assets that are used for downstream materializations,
that have high frequency upstream assets, but themselves do not need to be updated as
frequently.</p></div>
</dd>
<dt id="data_platform.utils.automation_conditions.CustomAutomationCondition.manual"><code class="name flex">
<span>def <span class="ident">manual</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def manual() -&gt; None:
     &#34;&#34;&#34;Returns no AutomationCondition that will require a user to manually trigger.
     Used for overriding default automations for static assets.
     &#34;&#34;&#34;
     return None</code></pre>
</details>
<div class="desc"><p>Returns no AutomationCondition that will require a user to manually trigger.
Used for overriding default automations for static assets.</p></div>
</dd>
<dt id="data_platform.utils.automation_conditions.CustomAutomationCondition.missing_or_changed"><code class="name flex">
<span>def <span class="ident">missing_or_changed</span></span>(<span>) ‑> dagster._core.definitions.declarative_automation.automation_condition.AutomationCondition</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def missing_or_changed() -&gt; AutomationCondition:
    &#34;&#34;&#34;Returns no AutomationCondition that will trigger only if the asset has never been
    materialized, or if its definition has changed.

    Common use for dbt seeds that only need to be reloaded when the underlying csv file changes.
     &#34;&#34;&#34;
    return (
        AutomationCondition.in_latest_time_window()
        &amp; (
            AutomationCondition.code_version_changed() | AutomationCondition.newly_missing()
        ).since_last_handled()
        &amp; ~ AutomationCondition.in_progress()
    ).with_label(f&#34;missing_or_changed&#34;)</code></pre>
</details>
<div class="desc"><p>Returns no AutomationCondition that will trigger only if the asset has never been
materialized, or if its definition has changed.</p>
<p>Common use for dbt seeds that only need to be reloaded when the underlying csv file changes.</p></div>
</dd>
<dt id="data_platform.utils.automation_conditions.CustomAutomationCondition.on_cron"><code class="name flex">
<span>def <span class="ident">on_cron</span></span>(<span>cron_schedule: str,<br>cron_timezone: str = 'UTC',<br>ignore_asset_keys: list[list[str]] | None = None) ‑> dagster._core.definitions.declarative_automation.operators.boolean_operators.AndAutomationCondition</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@override
def on_cron(
        cron_schedule: str,
        cron_timezone: str = &#34;UTC&#34;,
        ignore_asset_keys: list[list[str]]| None = None) -&gt; AndAutomationCondition:
    &#34;&#34;&#34;Returns an AutomationCondition which will cause a target to be
    executed on a given cron schedule, after all of its dependencies have
    been updated since the latest tick of that cron schedule.

    For time partitioned assets, only the latest time partition will be considered.
    
    Commonly used for assets that are far downstream and have users that directly
    interact with them, and have sensitivity to late arriving dimensions.&#34;&#34;&#34;
    ignore_asset_keys = ignore_asset_keys or []
    return AutomationCondition.on_cron(cron_schedule, cron_timezone).ignore(
        AssetSelection.assets(*ignore_asset_keys))</code></pre>
</details>
<div class="desc"><p>Returns an AutomationCondition which will cause a target to be
executed on a given cron schedule, after all of its dependencies have
been updated since the latest tick of that cron schedule.</p>
<p>For time partitioned assets, only the latest time partition will be considered.</p>
<p>Commonly used for assets that are far downstream and have users that directly
interact with them, and have sensitivity to late arriving dimensions.</p></div>
</dd>
<dt id="data_platform.utils.automation_conditions.CustomAutomationCondition.on_schedule"><code class="name flex">
<span>def <span class="ident">on_schedule</span></span>(<span>cron_schedule: str, cron_timezone: str = 'utc') ‑> dagster._core.definitions.declarative_automation.automation_condition.AutomationCondition</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def on_schedule(cron_schedule: str, cron_timezone: str = &#34;utc&#34;) -&gt; AutomationCondition:
    &#34;&#34;&#34;Returns an AutomationCondition which will cause a target to be executed on a given
    cron schedule, regardless of the state of its dependencies

    For time partitioned assets, only the latest time partition will be considered.

    Commonly used for assets in the ingestion layer that should always run on a scheduled basis,
    and have no way of knowing when the source system has updates.
    &#34;&#34;&#34;
    return (
        AutomationCondition.in_latest_time_window()
        &amp; AutomationCondition.cron_tick_passed(
            cron_schedule, cron_timezone
        ).since_last_handled()
    ).with_label(f&#34;on_schedule({cron_schedule}, {cron_timezone})&#34;)</code></pre>
</details>
<div class="desc"><p>Returns an AutomationCondition which will cause a target to be executed on a given
cron schedule, regardless of the state of its dependencies</p>
<p>For time partitioned assets, only the latest time partition will be considered.</p>
<p>Commonly used for assets in the ingestion layer that should always run on a scheduled basis,
and have no way of knowing when the source system has updates.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="data_platform.utils" href="index.html">data_platform.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="data_platform.utils.automation_conditions.CustomAutomationCondition" href="#data_platform.utils.automation_conditions.CustomAutomationCondition">CustomAutomationCondition</a></code></h4>
<ul class="">
<li><code><a title="data_platform.utils.automation_conditions.CustomAutomationCondition.eager" href="#data_platform.utils.automation_conditions.CustomAutomationCondition.eager">eager</a></code></li>
<li><code><a title="data_platform.utils.automation_conditions.CustomAutomationCondition.eager_with_deps_checks" href="#data_platform.utils.automation_conditions.CustomAutomationCondition.eager_with_deps_checks">eager_with_deps_checks</a></code></li>
<li><code><a title="data_platform.utils.automation_conditions.CustomAutomationCondition.get_automation_condition" href="#data_platform.utils.automation_conditions.CustomAutomationCondition.get_automation_condition">get_automation_condition</a></code></li>
<li><code><a title="data_platform.utils.automation_conditions.CustomAutomationCondition.lazy" href="#data_platform.utils.automation_conditions.CustomAutomationCondition.lazy">lazy</a></code></li>
<li><code><a title="data_platform.utils.automation_conditions.CustomAutomationCondition.lazy_on_cron" href="#data_platform.utils.automation_conditions.CustomAutomationCondition.lazy_on_cron">lazy_on_cron</a></code></li>
<li><code><a title="data_platform.utils.automation_conditions.CustomAutomationCondition.manual" href="#data_platform.utils.automation_conditions.CustomAutomationCondition.manual">manual</a></code></li>
<li><code><a title="data_platform.utils.automation_conditions.CustomAutomationCondition.missing_or_changed" href="#data_platform.utils.automation_conditions.CustomAutomationCondition.missing_or_changed">missing_or_changed</a></code></li>
<li><code><a title="data_platform.utils.automation_conditions.CustomAutomationCondition.on_cron" href="#data_platform.utils.automation_conditions.CustomAutomationCondition.on_cron">on_cron</a></code></li>
<li><code><a title="data_platform.utils.automation_conditions.CustomAutomationCondition.on_schedule" href="#data_platform.utils.automation_conditions.CustomAutomationCondition.on_schedule">on_schedule</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
